package net.sf.jabref.export.layout.format;

import net.sf.jabref.Globals;
import net.sf.jabref.export.layout.LayoutFormatter;

import java.util.HashMap;


public class FormatChars implements LayoutFormatter {

    public static HashMap<String, String> CHARS = new HashMap<String, String>();

    static {
		CHARS.put("`A", "Ã€"); 
		CHARS.put("'A", "Ã?"); 
		CHARS.put("^A", "Ã‚"); 
		CHARS.put("~A", "Ãƒ"); 
		CHARS.put("\"A", "Ã„"); 
		CHARS.put("AA", "Ã…"); 
		CHARS.put("AE", "Ã†"); 
		CHARS.put("cC", "Ã‡"); 
        CHARS.put("`E", "Ãˆ"); 
		CHARS.put("'E", "Ã‰"); 
		CHARS.put("^E", "ÃŠ"); 
		CHARS.put("\"E", "Ã‹"); 
		CHARS.put("`I", "ÃŒ"); 
		CHARS.put("'I", "Ã?"); 
		CHARS.put("^I", "ÃŽ"); 
		CHARS.put("\"I", "Ã?"); 
		CHARS.put("DH", "Ã?"); 
		CHARS.put("~N", "Ã‘"); 
		CHARS.put("`O", "Ã’"); 
		CHARS.put("'O", "Ã“"); 
		CHARS.put("^O", "Ã”"); 
		CHARS.put("~O", "Ã•"); 
		CHARS.put("\"O", "Ã–"); 
		
		
		
		CHARS.put("O", "Ã˜"); 
		CHARS.put("`U", "Ã™"); 
		CHARS.put("'U", "Ãš"); 
		CHARS.put("^U", "Ã›"); 
		CHARS.put("\"U", "Ãœ"); 
		CHARS.put("'Y", "Ã?"); 
		CHARS.put("TH", "Ãž"); 
		CHARS.put("ss", "ÃŸ"); 
		CHARS.put("`a", "Ã "); 
		CHARS.put("'a", "Ã¡"); 
		CHARS.put("^a", "Ã¢"); 
		CHARS.put("~a", "Ã£"); 
		CHARS.put("\"a", "Ã¤"); 
		CHARS.put("aa", "Ã¥"); 
		CHARS.put("ae", "Ã¦"); 
		CHARS.put("cc", "Ã§"); 
		CHARS.put("`e", "Ã¨"); 
		CHARS.put("'e", "Ã©"); 
		CHARS.put("^e", "Ãª"); 
		CHARS.put("\"e", "Ã«"); 
		CHARS.put("`i", "Ã¬"); 
		CHARS.put("'i", "Ã­"); 
		CHARS.put("^i", "Ã®"); 
		CHARS.put("\"i", "Ã¯"); 
		CHARS.put("dh", "Ã°"); 
		CHARS.put("~n", "Ã±"); 
		CHARS.put("`o", "Ã²"); 
		CHARS.put("'o", "Ã³"); 
		CHARS.put("^o", "Ã´"); 
		CHARS.put("~o", "Ãµ"); 
		CHARS.put("\"o", "Ã¶"); 
		
		
		
		CHARS.put("o", "Ã¸"); 
		CHARS.put("`u", "Ã¹"); 
		CHARS.put("'u", "Ãº"); 
		CHARS.put("^u", "Ã»"); 
		CHARS.put("\"u", "Ã¼"); 
		CHARS.put("'y", "Ã½"); 
		CHARS.put("th", "Ã¾"); 
		CHARS.put("\"y", "Ã¿"); 

		
		
		CHARS.put("=A", "Ä€"); 
		CHARS.put("=a", "Ä?"); 
		CHARS.put("uA", "Ä‚"); 
		CHARS.put("ua", "Äƒ"); 
		CHARS.put("kA", "Ä„"); 
		CHARS.put("ka", "Ä…"); 
		CHARS.put("'C", "Ä†"); 
		CHARS.put("'c", "Ä‡"); 
		CHARS.put("^C", "Äˆ"); 
		CHARS.put("^c", "Ä‰"); 
		CHARS.put(".C", "ÄŠ"); 
		CHARS.put(".c", "Ä‹"); 
		CHARS.put("vC", "ÄŒ"); 
		CHARS.put("vc", "Ä?"); 
		CHARS.put("vD", "ÄŽ"); 
		
		CHARS.put("DJ", "Ä?"); 
		CHARS.put("dj", "Ä‘"); 
		CHARS.put("=E", "Ä’"); 
		CHARS.put("=e", "Ä“"); 
		CHARS.put("uE", "Ä”"); 
		CHARS.put("ue", "Ä•"); 
		CHARS.put(".E", "Ä–"); 
		CHARS.put(".e", "Ä—"); 
		CHARS.put("kE", "Ä˜"); 
		CHARS.put("ke", "Ä™"); 
		CHARS.put("vE", "Äš"); 
		CHARS.put("ve", "Ä›"); 
		CHARS.put("^G", "Äœ"); 
		CHARS.put("^g", "Ä?"); 
		CHARS.put("uG", "Äž"); 
		CHARS.put("ug", "ÄŸ"); 
		CHARS.put(".G", "Ä "); 
		CHARS.put(".g", "Ä¡"); 
		CHARS.put("cG", "Ä¢"); 
		CHARS.put("'g", "Ä£"); 
		CHARS.put("^H", "Ä¤"); 
		CHARS.put("^h", "Ä¥"); 
		CHARS.put("Hstrok", "Ä¦"); 
		CHARS.put("hstrok", "Ä§"); 
		CHARS.put("~I", "Ä¨"); 
		CHARS.put("~i", "Ä©"); 
		CHARS.put("=I", "Äª"); 
		CHARS.put("=i", "Ä«"); 
		CHARS.put("uI", "Ä¬"); 
		CHARS.put("ui", "Ä­"); 
		CHARS.put("kI", "Ä®"); 
		CHARS.put("ki", "Ä¯"); 
		CHARS.put(".I", "Ä°"); 
		CHARS.put("i", "Ä±"); 
		
		
		CHARS.put("^J", "Ä´"); 
		CHARS.put("^j", "Äµ"); 
		CHARS.put("cK", "Ä¶"); 
		CHARS.put("ck", "Ä·"); 
		
		CHARS.put("'L", "Ä¹"); 
		CHARS.put("'l", "Äº"); 
		CHARS.put("cL", "Ä»"); 
		CHARS.put("cl", "Ä¼"); 
		
		
		CHARS.put("Lmidot", "Ä¿"); 
		CHARS.put("lmidot", "Å€"); 
		CHARS.put("L", "Å?"); 
		CHARS.put("l", "Å‚"); 
		CHARS.put("'N", "Åƒ"); 
		CHARS.put("'n", "Å„"); 
		CHARS.put("cN", "Å…"); 
		CHARS.put("cn", "Å†"); 
		CHARS.put("vN", "Å‡"); 
		CHARS.put("vn", "Åˆ"); 
		
		CHARS.put("NG", "ÅŠ"); 
		CHARS.put("ng", "Å‹"); 
		CHARS.put("=O", "ÅŒ"); 
		CHARS.put("=o", "Å?"); 
		CHARS.put("uO", "ÅŽ"); 
		CHARS.put("uo", "Å?"); 
		CHARS.put("HO", "Å?"); 
		CHARS.put("Ho", "Å‘"); 
		CHARS.put("OE", "Å’"); 
		CHARS.put("oe", "Å“"); 
		CHARS.put("'R", "Å”"); 
		CHARS.put("'r", "Å•"); 
		CHARS.put("cR", "Å–"); 
		CHARS.put("cr", "Å—"); 
		CHARS.put("vR", "Å˜"); 
		CHARS.put("vr", "Å™"); 
		CHARS.put("'S", "Åš"); 
		CHARS.put("'s", "Å›"); 
		CHARS.put("^S", "Åœ"); 
		CHARS.put("^s", "Å?"); 
		CHARS.put("cS", "Åž"); 
		CHARS.put("cs", "ÅŸ"); 
		CHARS.put("vS", "Å "); 
		CHARS.put("vs", "Å¡"); 
		CHARS.put("cT", "Å¢"); 
		CHARS.put("ct", "Å£"); 
		CHARS.put("vT", "Å¤"); 
		
		CHARS.put("Tstrok", "Å¦"); 
		CHARS.put("tstrok", "Å§"); 
		CHARS.put("~U", "Å¨"); 
		CHARS.put("~u", "Å©"); 
		CHARS.put("=U", "Åª"); 
		CHARS.put("=u", "Å«"); 
		CHARS.put("uU", "Å¬"); 
		CHARS.put("uu", "Å­"); 
		CHARS.put("rU", "Å®"); 
		CHARS.put("ru", "Å¯"); 
		CHARS.put("HU", "Å¯"); 
		CHARS.put("Hu", "Å±"); 
		CHARS.put("kU", "Å²"); 
		CHARS.put("ku", "Å³"); 
		CHARS.put("^W", "Å´"); 
		CHARS.put("^w", "Åµ"); 
		CHARS.put("^Y", "Å¶"); 
		CHARS.put("^y", "Å·"); 
		CHARS.put("\"Y", "Å¸"); 
		CHARS.put("'Z", "Å¹"); 
		CHARS.put("'z", "Åº"); 
		CHARS.put(".Z", "Å»"); 
		CHARS.put(".z", "Å¼"); 
		CHARS.put("vZ", "Å½"); 
		CHARS.put("vz", "Å¾"); 
		
        CHARS.put("%", "%"); 
    }

    public String format(String field) {
		int i;
		field = field.replaceAll("&|\\\\&", "&amp;").replaceAll("[\\n]{1,}", "<p>");

		StringBuffer sb = new StringBuffer();
		StringBuffer currentCommand = null;
		
		char c;
		boolean escaped = false, incommand = false;
		
		for (i = 0; i < field.length(); i++) {
			c = field.charAt(i);
			if (escaped && (c == '\\')) {
				sb.append('\\');
				escaped = false;
			} else if (c == '\\') {
				if (incommand){
					
					String command = currentCommand.toString();
					Object result = CHARS.get(command);
					if (result != null) {
						sb.append((String) result);
					} else {
						sb.append(command);
					}
				}
				escaped = true;
				incommand = true;
				currentCommand = new StringBuffer();
			} else if (!incommand && (c == '{' || c == '}')) {
				
			} else if (Character.isLetter(c) || (c == '%')
				|| (Globals.SPECIAL_COMMAND_CHARS.indexOf(String.valueOf(c)) >= 0)) {
				escaped = false;

                if (!incommand)
					sb.append(c);
					
				else {
					currentCommand.append(c);
                    testCharCom: if ((currentCommand.length() == 1)
						&& (Globals.SPECIAL_COMMAND_CHARS.indexOf(currentCommand.toString()) >= 0)) {
						
						
						if (i >= field.length() - 1)
							break testCharCom;

						String command = currentCommand.toString();
						i++;
						c = field.charAt(i);
						
						String combody;
						if (c == '{') {
							IntAndString part = getPart(field, i, false);
							i += part.i;
							combody = part.s;
						} else {
							combody = field.substring(i, i + 1);
							
						}
						Object result = CHARS.get(command + combody);

						if (result != null)
							sb.append((String) result);

						incommand = false;
						escaped = false;
					} else { 
						
						if (i + 1 == field.length()){
							String command = currentCommand.toString();
                            Object result = CHARS.get(command);
							
							if (result != null) {
								sb.append((String) result);
							} else {
								sb.append(command);
							}
							
						}
					}
				}
			} else {
				String argument = null;

				if (!incommand) {
					sb.append(c);
				} else if (Character.isWhitespace(c) || (c == '{') || (c == '}')) {
					
					
					

					String command = currentCommand.toString();
                                                
                    if (c == '{') {
						IntAndString part = getPart(field, i, true);
						i += part.i;
						argument = part.s;
						if (argument != null) {
							
							Object result = CHARS.get(command + argument);
							
							
							
							
							
							if (result != null) {
								sb.append((String) result);
							} else {
								sb.append(argument);
							}
						}
                    } else if (c == '}') {
                        
                        
                        
                        Object result = CHARS.get(command);
                        if (result != null) {
                            sb.append((String) result);
                        } else {
                            
                            sb.append(command);
                        }
                    } else {
						Object result = CHARS.get(command);
						if (result != null) {
							sb.append((String) result);
						} else {
							sb.append(command);
						}
						sb.append(' ');
					}
				} else {
					
				}
				
				incommand = false;
				escaped = false;
			}
		}

		return sb.toString();
	}

	private IntAndString getPart(String text, int i, boolean terminateOnEndBraceOnly) {
		char c;
		int count = 0;
		
		StringBuffer part = new StringBuffer();
		
		
		i++;
		while (i < text.length() && Character.isWhitespace(text.charAt(i))){
			i++;
		}
		
		
		while (i < text.length()){
			c = text.charAt(i);
			if (!terminateOnEndBraceOnly && count == 0 && Character.isWhitespace(c)) {
				i--; 
					 
				break;
			}
			if (c == '}' && --count < 0)
				break;
			else if (c == '{')
				count++;
			part.append(c);
			i++;
		}
		return new IntAndString(part.length(), format(part.toString()));
	}

	private class IntAndString {
		public int i;

		String s;

		public IntAndString(int i, String s) {
			this.i = i;
			this.s = s;
		}
	}
}


