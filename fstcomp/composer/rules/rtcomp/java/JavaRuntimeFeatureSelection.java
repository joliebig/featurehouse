package composer.rules.rtcomp.java;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import metadata.CompositionMetadataStore;

public class JavaRuntimeFeatureSelection {

	CompositionMetadataStore meta;
	private File cnfFile;
	private String javaFileContents;
	
	public static boolean addJPF_BDD_Annotation = false;
	
	public JavaRuntimeFeatureSelection(CompositionMetadataStore meta, File cnfFile) {
		this.meta = meta;
		this.cnfFile = cnfFile;
	}
	
	public void process() {
		javaFileContents =
			"package verificationClasses;\n" +
			//"import gov.nasa.jpf.annotation.FilterField;\n" +
			//"import gov.nasa.jpf.symbc.Symbolic;\n" +
			"public class FeatureSwitches {\n" +
			"/*\n" +
			" * DO NOT EDIT! THIS FILE IS AUTOGENERATED BY fstcomp \n" +
			" */\n" +
			"\n";
		
		// a global variable per feature
		List<String> features = meta.getFeatures();
		for (String feature: features) {
			//javaFileContents += "@FilterField\npublic static boolean __SELECTED_FEATURE_" + feature + ";\n";
			if (addJPF_BDD_Annotation)
				javaFileContents += "@gov.nasa.jpf.bdd.TrackWithBDD\n";
			javaFileContents += "public static boolean __SELECTED_FEATURE_" + feature + ";\n";
			//javaFileContents += "@Symbolic(\"true\")\npublic static boolean __SELECTED_FEATURE_" + feature + ";\n";
		}
		javaFileContents += "public static String getSelectedFeaturesAsNames() {\n" +
				"StringBuilder sb = new StringBuilder();\n";
		for (String feature: features) {
			javaFileContents += "\tif (__SELECTED_FEATURE_" + feature + ") sb.append(\""+feature+";\");\n";
		}
		javaFileContents += "return sb.toString();\n" +
				"}\n";
		
	
		javaFileContents += "public static void select_features() {\n";
		
		for (String feature : features) {
			javaFileContents += "\t__SELECTED_FEATURE_" + feature + " = verificationClasses.SPLModelChecker.getBoolean();\n";
		}
		
		javaFileContents += "}\n\n";
				
		processRestrictions();
		javaFileContents += "}";
	}
	
	public void saveTo(String filebasename) throws IOException {
		process();
		FileWriter javafile = null;
		try{
			javafile = new FileWriter(filebasename + "FeatureSwitches.java");
			javafile.write(javaFileContents);	
		}finally {
			if (javafile != null) {
				javafile.close();
			}
		}
	}
	 
	public void processRestrictions() {
		Scanner scanner = null;
		try {
			scanner = new Scanner(cnfFile);
		} catch (FileNotFoundException e) {
			System.out.println("model restrictions file not found!");
			System.out.println("looked in: " + cnfFile);
			throw new RuntimeException();
		}
		
		scanner.useDelimiter("\\A");
		
		String cnf = scanner.next();
		scanner.close();
		
		cnf = cnf.replaceAll("//[^\\n]*", ""); //strip comments
		cnf = cnf.replaceAll(" \\r", " ");
		cnf = cnf.replaceAll(" \\n", " ");
		cnf = cnf.replaceAll("\\n", " ");
		cnf = cnf.replaceAll("xor ", "^ ");
		cnf = cnf.replaceAll("and ", "&& ");
		cnf = cnf.replaceAll("or ", "|| ");
		cnf = cnf.replaceAll("not ", "! ");
		cnf = cnf.replaceAll(" \\r", "");
		cnf = cnf.replaceAll("\\r", "");
		cnf = cnf.replaceAll("\\(", "( ");
		cnf = cnf.replaceAll("\\)", " )");
	    
	    Pattern varsRegEx = Pattern.compile("[a-zA-Z_]+[a-zA-Z0-9_]+");
		Matcher matcher = varsRegEx.matcher(cnf);

		Set<String> variables = new HashSet<String>();
		Set<String> nonterminals = new HashSet<String>();
		
		if (!matcher.find()) {
			System.out.println("Expected at least one production in cnfFile, none found!!");
			throw new RuntimeException();
		}
		matcher.reset();// start from the beginning again
		// Find all matches
	    while (matcher.find()) {	      
	      variables.add(matcher.group());
	    }
		
	    for (String var: variables) {
	    	
	    	String replacement;
	    	if (meta.getFeatures().contains(var)) {
	            replacement = "__SELECTED_FEATURE_" + var;
	        } else {
	            replacement = "__GUIDSL_NON_TERMINAL_" + var;
	            nonterminals.add(replacement);
	        }
	    	// replace feature variables in string
	    	if (cnf.matches(".*" + "\\s" + var)) {
	        	cnf = cnf + " "; // this causes the next line to find the feature variable
	        }
	        cnf = cnf.replaceAll("\\s" + var + "\\s", ' ' + replacement + ' ');
	        // if the first letter is the start of a feature variable, we can use replaceFirst
	        if (cnf.matches(var + "\\s" + ".*")) {
	        	cnf = cnf.replaceFirst(var + "\\s", replacement + ' ');
	        }
	    }
	    
	    //cosmetics
	    cnf = cnf.replaceAll("\\) \\)","))");
	    cnf = cnf.replaceAll("\\( \\(","((");
	    cnf = cnf.replaceAll("! ","!");

		javaFileContents += "public static boolean __GUIDSL_ROOT_PRODUCTION;\n";
	    
	    for (String nt: nonterminals) {
	    	javaFileContents += "public static boolean " + nt + ";\n";
	    }
	    
		StringBuffer res = new StringBuffer();
	    
	    res.append("\npublic static void select_helpers() {\n");
	    res.append("\t__GUIDSL_ROOT_PRODUCTION = true;\n");
	    for (String nt: nonterminals) {
	        //res.append("\t" + nt + " = select_one();\n");
	    	res.append("\t" + nt + " = true;\n");
	    }    
	    res.append("}\n\n");	    
	    res.append("public static boolean valid_product() {\n");
	    // version with single return statement
	    //res.append("\t return " + cnf + ";\n");
	    
	    // more complex version with two return statements, to have the featureVars in an if statement
	    res.append("\tif (" + cnf + ")\n" +
	    		"\t\treturn true;\n" +
	    		"\telse\n" +
	    		"\t\treturn false;\n");
	    res.append("}\n");
		
		javaFileContents += res.toString();
	}
	
	
}
