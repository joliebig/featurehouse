options{  STATIC = false;  OUTPUT_DIRECTORY = "astgen/nparser/parser";}PARSER_BEGIN(SlimJJParser)package cide.astgen.nparser.parser;import cide.astgen.nparser.ast.*;import java.util.*;import cide.astgen.nparser.ast.NAbstractValue.Type;public class SlimJJParser{/**	 * Accumulate {@link Token} objects from the token stream until a token	 * matching <code>tokenKind</code> is consumed from the stream. The tokens	 * are accumulated in <code>buffer</code>, including the terminating	 * token.	 * 	 * @return a {@link Token} formed by concatenating all intervening tokens	 *         and special tokens.	 */	final private Token accumulateUntilToken(int tokenKind)			throws ParseException {		StringBuffer buffer = new StringBuffer();		Token token = getNextToken();		// Initialize result with known information (starting position, etc.):		//		Token result = Token.newToken(OTHER);		result.specialToken = null;		Token startToken = firstSpecial(token);		result.beginColumn = startToken.beginColumn;		result.beginLine = startToken.beginLine;		// Accumulate tokens until a <code>tokenKind</code> token is found:		//		while (token.kind != tokenKind) {			// Update information in result:			//			result.endColumn = token.endColumn;			result.endLine = token.endLine;			result.next = token.next;			if (token.kind == EOF)				throw new ParseException("from line " + result.beginLine						+ " at column " + result.beginColumn						+ ": EOF reached before " + tokenImage[tokenKind]						+ " found");			accumulate(token, buffer);			token = getNextToken();		}		accumulate(token, buffer);		result.image = buffer.toString();		return result;	}	private static boolean lastCharWasLetter=false;	/**	 * Append the given {@link Token} and any preceding special tokens to a	 * given {@link StringBuffer}.	 * 	 * @param token	 *            the given JavaCC {@link Token} object	 * @param buffer	 *            the buffer to which to append <code>token</code>	 */	final private static void accumulate(Token token, StringBuffer buffer) {		if (token.image.equals("GRAMMARSTART")) return;		// Append preceding special tokens to <code>buffer</code>:		//		Token special = firstSpecial(token);		if (special != token)			while (special != null) {				String i = special.image;				if (lastCharWasLetter && Character.isLetter(i.charAt(0)))					i = " " + i;				lastCharWasLetter = Character						.isLetter(i.charAt(i.length() - 1));				buffer.append(i);				special = special.next;			}		// Finally, append the token itself:		//		String i = token.image;		if (lastCharWasLetter && Character.isLetter(i.charAt(0)))			i = " " + i;		lastCharWasLetter = Character.isLetter(i.charAt(i.length() - 1));		buffer.append(i);	}	/**	 * Finds the first token, special or otherwise, in the list of special	 * tokens preceding this {@link Token}. If this list is non-empty, the	 * result will be a special token. Otherwise, it will be the starting token.	 * 	 * @param token	 *            the given {@link Token}.	 * @return the first special token preceding <code>token</code>.	 */	final private static Token firstSpecial(Token token) {		while (token.specialToken != null)			token = token.specialToken;		return token;	}}PARSER_END(SlimJJParser)/* WHITE SPACE */SPECIAL_TOKEN:{  " "  | "\t"  | "\n"  | "\r"  | "\f"}/* COMMENTS */MORE:{  "//":IN_SINGLE_LINE_COMMENT  | <"/**"~["/"]>{    input_stream.backup(1);  }  :IN_FORMAL_COMMENT  | "/*":IN_MULTI_LINE_COMMENT}<IN_SINGLE_LINE_COMMENT>SPECIAL_TOKEN:{  <SINGLE_LINE_COMMENT:"\n"  | "\r"  | "\r\n">:DEFAULT}<IN_FORMAL_COMMENT>SPECIAL_TOKEN:{  <FORMAL_COMMENT:"*/">:DEFAULT}<IN_MULTI_LINE_COMMENT>SPECIAL_TOKEN:{  <MULTI_LINE_COMMENT:"*/">:DEFAULT}<IN_SINGLE_LINE_COMMENT, IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT>MORE:{  <~[]>}/* RESERVED WORDS AND LITERALS */TOKEN:{   <GRAMMARSTART:"GRAMMARSTART">  | <ABSTRACT:"abstract">  | <ASSERT:"assert">  | <BOOLEAN:"boolean">  | <BREAK:"break">  | <BYTE:"byte">  | <CASE:"case">  | <CATCH:"catch">  | <CHAR:"char">  | <CLASS:"class">  | <CONST:"const">  | <CONTINUE:"continue">  | <_DEFAULT:"default">  | <DO:"do">  | <DOUBLE:"double">  | <ELSE:"else">  | <ENUM:"enum">  | <EXTENDS:"extends">  | <FALSE:"false">  | <FINAL:"final">  | <FINALLY:"finally">  | <FLOAT:"float">  | <FOR:"for">  | <GOTO:"goto">  | <IF:"if">  | <IMPLEMENTS:"implements">  | <IMPORT:"import">  | <INSTANCEOF:"instanceof">  | <INT:"int">  | <INTERFACE:"interface">  | <LONG:"long">  | <NATIVE:"native">  | <NEW:"new">  | <NULL:"null">  | <PACKAGE:"package">  | <PRIVATE:"private">  | <PROTECTED:"protected">  | <PUBLIC:"public">  | <RETURN:"return">  | <SHORT:"short">  | <STATIC:"static">  | <STRICTFP:"strictfp">  | <SUPER:"super">  | <SWITCH:"switch">  | <SYNCHRONIZED:"synchronized">  | <THIS:"this">  | <THROW:"throw">  | <THROWS:"throws">  | <TRANSIENT:"transient">  | <TRUE:"true">  | <TRY:"try">  | <VOID:"void">  | <VOLATILE:"volatile">  | <WHILE:"while">  | <LOOK_AHEAD:"LOOK_AHEAD">  | <LL:"LL">  | <OPTIONAL:"OPTIONAL">  | <JAVA:"JAVA">  | <JAVATOKEN:"JAVATOKEN">}/* LITERALS */TOKEN:{  <INTEGER_LITERAL:<DECIMAL_LITERAL>(["l", "L"])?  | <HEX_LITERAL>(["l", "L"])?  | <OCTAL_LITERAL>(["l", "L"])?>  | <#DECIMAL_LITERAL:["1"-"9"](["0"-"9"])*>  | <#HEX_LITERAL:"0"["x", "X"](["0"-"9", "a"-"f", "A"-"F"])+>  | <#OCTAL_LITERAL:"0"(["0"-"7"])*>  | <FLOATING_POINT_LITERAL:(["0"-"9"])+"."(["0"-"9"])*(<EXPONENT>)?(["f", "F", "d", "D"])?  | "."(["0"-"9"])+(<EXPONENT>)?(["f", "F", "d", "D"])?  | (["0"-"9"])+<EXPONENT>(["f", "F", "d", "D"])?  | (["0"-"9"])+(<EXPONENT>)?["f", "F", "d", "D"]>  | <#EXPONENT:["e", "E"](["+", "-"])?(["0"-"9"])+>  | <CHARACTER_LITERAL:"'"((~["'", "\\", "\n", "\r"])  | ("\\"(["n", "t", "b", "r", "f", "\\", "'", "\""]  | ["0"-"7"](["0"-"7"])?  | ["0"-"3"]["0"-"7"]["0"-"7"])))"'">  | <STRING_LITERAL:"\""((~["\"", "\\", "\n", "\r"])  | ("\\"(["n", "t", "b", "r", "f", "\\", "'", "\""]  | ["0"-"7"](["0"-"7"])?  | ["0"-"3"]["0"-"7"]["0"-"7"])))*"\"">}/* SEPARATORS */TOKEN:{  <LPAREN:"(">  | <RPAREN:")">  | <LBRACE:"{">  | <RBRACE:"}">  | <LBRACKET:"[">  | <RBRACKET:"]">  | <SEMICOLON:";">  | <COMMA:",">  | <DOT:".">  | <AT:"@">}/* OPERATORS */TOKEN:{  <ASSIGN:"=">  | <LT:"<">  | <GT:">">  | <BANG:"!">  | <TILDE:"~">  | <HOOK:"?">  | <COLON:":">  | <EQ:"==">  | <LE:"<=">  | <GE:">=">  | <NE:"!=">  | <SC_OR:"||">  | <SC_AND:"&&">  | <INCR:"++">  | <DECR:"--">  | <PLUS:"+">  | <MINUS:"-">  | <STAR:"*">  | <SLASH:"/">  | <BIT_AND:"&">  | <BIT_OR:"|">  | <XOR:"^">  | <REM:"%">  | <LSHIFT:"<<">  | <PLUSASSIGN:"+=">  | <MINUSASSIGN:"-=">  | <STARASSIGN:"*=">  | <SLASHASSIGN:"/=">  | <ANDASSIGN:"&=">  | <ORASSIGN:"|=">  | <XORASSIGN:"^=">  | <REMASSIGN:"%=">  | <LSHIFTASSIGN:"<<=">  | <RSIGNEDSHIFTASSIGN:">>=">  | <RUNSIGNEDSHIFTASSIGN:">>>=">  | <ELLIPSIS:"...">}/* IDENTIFIERS */TOKEN:{  <IDENTIFIER:<LETTER>(<LETTER>  | <DIGIT>)*>  | <#LETTER:["\u0024", "\u0041"-"\u005a", "\u005f", "\u0061"-"\u007a", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff"]>  | <#DIGIT:["\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049"]>  | <OTHER: ~[]>}JAVACODEToken findIntroductionBlock () {    return accumulateUntilToken (GRAMMARSTART) ;}NGrammar Grammar():{  NGrammar result;  NProduction p;  Token t;}{  t=findIntroductionBlock()   {    result = new NGrammar(t.toString());  }  (p = Production(result){    result.productions.add(p);  }  )+  <EOF>  {    return result;  }}NProduction Production(NGrammar grammar):{  Token n;  NChoice c;  NProduction result;  NAnnotation a;}{	{result = new NProduction(grammar);}  (a=Annotation() {result.addAnnotation(a);} )*  n = <IDENTIFIER>  { result.setName(n.toString()); }  ":"c = Choice(result){    result.addChoice(c);  }  ("|"c = Choice(result){    result.addChoice(c);  }  )*";"{    return result;  }}NChoice Choice(NProduction production):{  NChoice result;  NAbstractValue m;  NAnnotation a;  Token t;  String i;  List<String>tokenlist = new ArrayList<String>();}{	 { result = new NChoice(production);  }    //Annoations first?  (LOOKAHEAD(2) a=Annotation() {result.addAnnotation(a);} )*(		LOOKAHEAD((Text())* Mult()) 				 (i = Text()  { tokenlist.add(i);} )*	  	  	m = Mult(result)	  	{result.units.add(m);m.outerPreTokens.addAll(tokenlist);}	  	  	  	(PostText(m.outerPostTokens))*	  	  ( 	  		m = Mult(result)  {result.units.add(m);}	  		(PostText(m.outerPostTokens))*	  )*	  	  	  ["::"t = <IDENTIFIER>{	    result.optName = t.toString();	  }	  ]	  	  {return result;} 	  	 |	  i=Text()	  { m=new NTextOnly(result, Type.ONE);	  	m.outerPreTokens.add(i);	  	result.units.add(m);	    return result;})}NAbstractValue Mult(NChoice choice):{  NAbstractValue u;  List<String>tokenlist = new ArrayList<String>();  String i;  Token t;}{  LOOKAHEAD(OneOrMore(choice)) u=OneOrMore(choice) {return u;} |    LOOKAHEAD(ZeroOrMore(choice)) u=ZeroOrMore(choice) {return u;} |   LOOKAHEAD(Wrappee(choide)) u= Wrappee(choice) {return u;} |     LOOKAHEAD(OneOrZero(choice)) u=OneOrZero(choice) {return u;} |   u = Unit(choice, Type.ONE){return u;} |    u= OptionalWithDefault(choice) {return u;}  }NAbstractValue OneOrMore(NChoice choice) : {  NAbstractValue u;  List<String>tokenlist = new ArrayList<String>();  String i;} {  "("  (i = Text(){tokenlist.add(i);} )*  u = Unit(choice, Type.ONEORMORE)  {u.innerPreTokens.addAll(tokenlist);}  (PostText(u.innerPostTokens))*  ")"  "+"  {return u;}}NAbstractValue ZeroOrMore(NChoice choice) : {  NAbstractValue u;  List<String>tokenlist = new ArrayList<String>();  String i;} {  "("  (i = Text(){tokenlist.add(i);})*  u = Unit(choice, Type.ZEROORMORE)  {u.innerPreTokens.addAll(tokenlist);}  (PostText(u.innerPostTokens))*  ")"  "*"  {return u;} } NAbstractValue OneOrZero(NChoice choice) : {  NAbstractValue u;  List<String>tokenlist = new ArrayList<String>();  String i;} { ( "["  (i = Text(){tokenlist.add(i);})*  u = Unit(choice, Type.ZEROORONE)  {u.innerPreTokens.addAll(tokenlist);}  (PostText(u.innerPostTokens))*  "]"  {return u;} |  "("  (i = Text(){tokenlist.add(i);})*  u = Unit(choice, Type.ZEROORONE)  {u.innerPreTokens.addAll(tokenlist);}  (PostText(u.innerPostTokens))*  ")" "?"  {return u;}  ) }  NAbstractValue OptionalWithDefault(NChoice choice) : {  NAbstractValue u;  Token t;} {  "OPTIONAL"  "("  u = Unit(choice, Type.OPTIONALWITHDEFAULT)  ","  t = <STRING_LITERAL>  ")"  { u.defaultValue = t.toString(); return u; }}NAbstractValue Wrappee(NChoice choice) : {  NAbstractValue u;} {  u = Unit(choice, Type.ONE)  "!"  { u.isWrappee=true; return u; }}NAbstractValue Unit(NChoice choice, Type type):{  NAbstractValue r;  String a=null;}{ [ a=ASTGeneratorAnnotation() ]   (    	r = NonTerminal(choice, type)       | r = Ident(choice, type)  )  { if (a!=null) r.innerPreTokens.add(a);  	return r;  }}NNonTerminal NonTerminal(NChoice choice, Type type):{  Token i;  NNonTerminal r;}{  i = <IDENTIFIER>  {r=new NNonTerminal(choice, type, i.toString());}  [ LOOKAHEAD(3) "{" i=<IDENTIFIER> "}" {r.setWrapsAroundType(i.toString());} ]  {return r;}}NAbstractValue Ident(NChoice choice, Type type):{  Token i;}{( 		"JAVATOKEN" "("	i=<IDENTIFIER> ")"		{ return new NJavaToken(choice, type, i.toString());} 	|		"<"i = <IDENTIFIER>">"	{if (i.toString().equals("NONE")) return new NTextOnly(choice, type);  		else return new NValue(choice, type, i.toString());})}String Text():{  Token i;  String s;}{	s = Lookahead() {return s;} |	s = Java() {return s;} |  	i = <STRING_LITERAL> {return i.toString();}//| //	LOOKAHEAD(2) s = Annotation()  { return s; }| 	s = LayoutHint()  { return s; }}void PostText(List<String>list):{  Token i;  String s;}{	s = Lookahead() {list.add(s);} |	s = Java() {list.add(s);} | 	i = <STRING_LITERAL> {list.add(i.toString());}//| //	LOOKAHEAD(2) s = Annotation()  {list.add(s); }| 	s = LayoutHint()  {list.add(s);}}String LayoutHint():{  String result = "@";}{  "@"  	[	"+"{result+="+";}]  	[   "-"{result+="-";}]  	[   "!"{result+="n";}]  	[   "~"{result+="s";}]  	[   "&"{result+="&";}]  	[   "%"{result+="%";}]  	{return result;}}////Annoations in the format @X([Y])//String Annotation(): {//	Token i,j=null;//}{//	"@" i=<IDENTIFIER> "(" [j=<IDENTIFIER>] ")"//	{return "@"+i.toString()+"("+(j==null?"":j.toString())+")";}//}NAnnotation Annotation(): { NAnnotation a;} {(   LOOKAHEAD( "@" <IDENTIFIER> "(" ( <IDENTIFIER> "=" | ")" ))   a=NormalAnnotation() |   LOOKAHEAD( "@" <IDENTIFIER> "(" )   a=SingleMemberAnnotation() |   a=MarkerAnnotation()) {return a;}   }NAnnotation  NormalAnnotation():{Token i;NAnnotation a;}{   "@" i=<IDENTIFIER> {a= new NAnnotation(i.toString());}   "(" [ MemberValuePairs(a) ] ")"  {return a;}}NAnnotation  MarkerAnnotation():{Token i;}{  "@" i=<IDENTIFIER>  {return new NAnnotation(i.toString());}}NAnnotation  SingleMemberAnnotation():{Token i;String v;NAnnotation a;}{  "@" i=<IDENTIFIER> "(" v=AnnotationValue() ")"  {a=new NAnnotation(i.toString());a.addValue("value",v); return a;}}void MemberValuePairs(NAnnotation a):{}{   MemberValuePair(a) ( "," MemberValuePair(a) )*}void MemberValuePair(NAnnotation a):{Token n;String v;}{    n=<IDENTIFIER> "=" v=AnnotationValue()    {a.addValue(n.toString(), v.toString());}}String AnnotationValue(): {Token v;}{	v=<INTEGER_LITERAL>	{return v.toString();}	|	v=<STRING_LITERAL>	{return v.toString();}}String ASTGeneratorAnnotation():{}{	"&LI"	{return "&LI";}}
String Lookahead():{  Token i;}{  ("LOOK_AHEAD"|"LL") "("(i = <INTEGER_LITERAL>|i=<STRING_LITERAL>)")"{      return "L"+i.image;  }}String Java():{  Token i;}{  <JAVA>"("i = <STRING_LITERAL>")"{    return "J"+i.image;  }}